# Python_AL

11-20 AL

# Div(Binary) ALG
  1. 자료가 크기순으로 정렬되어 있을 것. (Reverse 상관 X)
  2. List를 반으로 쪼갬 있을법한 곳을 
  3. 대충 속도가 매우 빠르다 콘
  4. log(2)100

# 원리
  1. List를 반으로 쪼개(중앙기준으로)
  2. 원하는 값이 있는 범위로 접근 = 해당 안되는 범위를 제외해버림(빠름)

그러면 list를 len 해서 값을 //2 하고나서 그 값으로 셀을 선택해버리기? = 중간값 (이분)
그리고 나눠진 list len //2 반복해  = 범위가 계속 좁혀짐
값이 더 크다면 오른쪽으로 작다면 왼쪽으로 범위를 좁혀가는 과정. 뛸떄마다 거리는 //2가 됨

# FIFO / LIFO 회문 
  1.qu/st 의 방식을 정리한다
  2.어떤 문장이 있을떄 앞과 뒤 서로 대체하여도 값이 같은 경우에 사용한다
  3.Qu/ST에서 FIFO/LIFO의 개념 그대로 서칭을 한다 만약 이게 꺼낸 순서와 역순이 일치한다면 회문임이 증명된다
  
여기서 Qu = append/pop()지정 안해주면 제일 마지막놈 / 아니면 너가 대상위치를 지정하던가 0 or -1 등등.. // 
stack은 pop써야만 한다! ()은 qu에서 꼭 지정해줘야해 까먹기금지

elif문을 통한 다가가는 내용이 같지 않다면 이게 메인 
// 한글자라도 틀리면 바로 False // 좌-우 에서 확인해보고 // 서로 교차될때까지 진행한다면 True값을 줌 

# 동명의인찿기
dict['',1] 쓰는거 기억하지 / 얜 STR값이랑 INT값을 매칭시켜둚 // Hash Slot

d[] 안에 같은사람의 이름이 있다면 for 문 써서  if in 해서 있ㅇ으면 +=1 해서 증가시키기 없으면 초기화
그리고나서 값이 증가한걸 return res로 뺴내주면 됨

dict 쓰면 아무튼 빠름 // 메모리많이씀 O(n)
list 약간느림 // 멤적게씀 O(n2)

  
# Dict 로 대상 찿아보기  / 11-27 AL
그냥 해당 dict내에서 뭐 있나 찍어서 찿아보기 list할때랑 비슷한 맛임
그냥 딕셔너리를 만들때부터 데이터를 넣어서 바로 색인하기  =  O(1) //한번에 찿을수있는 "정렬되어 있다면"

  1.친구찿기 알고리즘
    대충 서로 일촌관계/이촌관계/3촌관계/4촌관계 등등으로 정리가 되잖아 
    이거 DS Tree 그거 아님? 순회형으로 어디서 많이 본,,,, Graph잔아?
    Ex. 싸이월드같은 촌수개념에 + 친밀도로 보자면 1:1로 알면 친밀도가 1 (이걸 촌수로 보면 된다) 건너 2/ 건너건너면 3 

    vertex to edge // nord to edge




  

